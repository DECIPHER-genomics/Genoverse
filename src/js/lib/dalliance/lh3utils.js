// Adapted from https://github.com/dasmoth/dalliance/blob/master/js/lh3utils.js

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// lh3utils.js: common support for lh3's file formats
//

import inflateBuffer from './jszlib-inflate';

function Vob(b, o) {
  this.block = b;
  this.offset = o;
}

Vob.prototype.toString = function() {
  return '' + this.block + ':' + this.offset;
}

function readVob(ba, offset, allowZero) {
  var block = ((ba[offset+6] & 0xff) * 0x100000000) + ((ba[offset+5] & 0xff) * 0x1000000) + ((ba[offset+4] & 0xff) * 0x10000) + ((ba[offset+3] & 0xff) * 0x100) + ((ba[offset+2] & 0xff));
  var bint = (ba[offset+1] << 8) | (ba[offset]);
  if (block == 0 && bint == 0 && !allowZero) {
      return null;  // Should only happen in the linear index?
  } else {
      return new Vob(block, bint);
  }
}

function unbgzf(data, lim) {
  lim = Math.min(lim || 1, data.byteLength - 50);
  var oBlockList = [];
  var ptr = [0];
  var totalSize = 0;

  while (ptr[0] < lim) {
      var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?
      var xlen = (ba[11] << 8) | (ba[10]);
      // dlog('xlen[' + (ptr[0]) +']=' + xlen);
      var unc = inflateBuffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);
      ptr[0] += 8;
      totalSize += unc.byteLength;
      oBlockList.push(unc);
  }

  if (oBlockList.length == 1) {
      return oBlockList[0];
  } else {
      var out = new Uint8Array(totalSize);
      var cursor = 0;
      for (var i = 0; i < oBlockList.length; ++i) {
          var b = new Uint8Array(oBlockList[i]);
          arrayCopy(b, 0, out, cursor, b.length);
          cursor += b.length;
      }
      return out.buffer;
  }
}

function Chunk(minv, maxv) {
  this.minv = minv; this.maxv = maxv;
}


//
// Binning (transliterated from SAM1.3 spec)
//

/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */
function reg2bin(beg, end)
{
  --end;
  if (beg>>14 == end>>14) return ((1<<15)-1)/7 + (beg>>14);
  if (beg>>17 == end>>17) return ((1<<12)-1)/7 + (beg>>17);
  if (beg>>20 == end>>20) return ((1<<9)-1)/7 + (beg>>20);
  if (beg>>23 == end>>23) return ((1<<6)-1)/7 + (beg>>23);
  if (beg>>26 == end>>26) return ((1<<3)-1)/7 + (beg>>26);
  return 0;
}

/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */
var MAX_BIN = (((1<<18)-1)/7);
function reg2bins(beg, end)
{
  var i = 0, k, list = [];
  --end;
  list.push(0);
  for (k = 1 + (beg>>26); k <= 1 + (end>>26); ++k) list.push(k);
  for (k = 9 + (beg>>23); k <= 9 + (end>>23); ++k) list.push(k);
  for (k = 73 + (beg>>20); k <= 73 + (end>>20); ++k) list.push(k);
  for (k = 585 + (beg>>17); k <= 585 + (end>>17); ++k) list.push(k);
  for (k = 4681 + (beg>>14); k <= 4681 + (end>>14); ++k) list.push(k);
  return list;
}

export {
  unbgzf,
  readVob,
  reg2bin,
  reg2bins,
  Chunk,
};
